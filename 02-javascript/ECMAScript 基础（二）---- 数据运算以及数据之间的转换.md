# ECMAScript 基础（二）---- 数据运算以及数据处理
​	ECMAScript中，数据的运算主要是数学运算和逻辑运算，广义上将，我觉得数组的元素和对象属性值的增删改也算数据的运算，但本文不予讨论。数据之间的转换，我认为主要是数据内置的一些方法，显式的返回另外类型的数据；或是在运算中，隐式的转换成其他的数据类型。

## 一、 ECMAScript 的数据运算

​	在ECMAScript中，数据的运算主要包括四则运算，比较运算，三元运算，逻辑运算，使用Math对象进行的运算，日期时间运算。除了Math对象和日期时间对象Date的运算，其他的运算都是由运算操作符来实现的，每种运算都有对应的操作符。
### （一） 四则运算
​	四则运算主要包括： +, -, *, /, % ,和 = 操作符组合的 +=, -=, *=, /=, %= 等复合赋值操作, 数据的自增和自减。
​	四则运算主要是对 Number 类型的数据进行处理，但是 + 作为连接符的时候，能对字符串进行拼接操作，因此在实际使用 + 操作符的时候，需要注意符号两边的数据类型。

​	-, *, / 可以有显式数据类型转换的作用，也就是把其他类型的数据，转换成 Number 类型的数据。由于这三种操作符期望返回的数据类型是 Number 类型，因此 ECMAScript 内部的实现就是将数据尽可能的转换成 Number 类型（后面每种数据类型的处理会谈到）。

#### 1. 简单操作

​	+ , - , * , / 和 % 操作符，是最基础的运算符，对 Number 类型做处理时，就是进行简单的四则处理。 当 + 操作符有一边是字符串类型的时候，是作为字符串的拼接操作符，能对字符串进行拼接（也可以直接模板字符串）。在处理 + 号的时候，需要注意两边的数据类型，否则可能得不到想要的数据。

#### 2. 自增自减操作

​	++ 和 -- 操作符，可以对Number类型的变量进行自增和自减运算。需要注意的是区分前自增（自减）和后自增（自减）的区别。前自增，是会先对变量进行自增操作，再进行表达式的取值运算；后自增，是先获取表达式的值，再进行变量的自增操作。
```javascript
let a = 2;
let b = 2;
console.log(a++); //2
console.log(a); //3
console.log(++b); //3
console.log(b); //3
```

#### 3. 复合赋值操作

​	复合赋值操作，是对运算和赋值操作的简写，只使用一个运算符，做两个操作。

```javascript
let a = 2;
a += 3; // 等同于 a = a + 3;
console.log(a); //5
```

### （二） 比较运算

​	比较运算是用关系操作符( < , > ,<= , >= )和相等操作符( == , != , ===, !== )来完成的。

​	在使用关系操作符的时候，有如下规则：

1. 如果有一个操作数是 undefined，始终返回 false（可以理解为，undefined 不参与关系操作符的比较运算）；

2. 如果两边是数值，则进行数值大小比较；

3. 如果两边是字符串，则比较两个字符串对应的字符编码值，并挨个字符从前往后比较；

4. 如果有一个操作数是数值，那么将另一个操作数转换为数值类型（使用Number()方法隐式转换），然后做大小比较；

5. 如果有一个操作数是对象，则调用valueOf() 方法，用得到的值执行比较；如果没有valueOf() 方法，则调用toString() 方法，用得到的值进行比较；

6. 如果有一个值是布尔值，则将其转化为数值类型，然后做比较。

7. 如果有一个操作数是 null， 会先转换成 0，然后做比较；

      总结（优先级）： 如果有一个操作数是布尔值或数值，则都转化成数值然后比较；如果有一个操作数是对象，则进行类型转换之后比较；如果有undefined， 则

   在使用相等操作符的时候，基本规则与关系操作符一致，除了在判断 == 操作的时候，把 null 当成 undefined 就行，有如下规则：

   [==操作符的算法过程](http://es6.ruanyifeng.com/?search=%E9%80%97%E5%8F%B7&x=4&y=9#docs/spec#%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6)

​	这样就会有一个很有意思的现象： null > 0 返回false , null < 0 返回 false ， null == 0 返回false ，但是 null >= 0 返回true ， null  <= 0 返回true 。
​	在网上寻找答案，有一个教程说是 null <= 0 和 null >= 0 是取的 !(null > 0) 和 !(null < 0)

### （三） 三元运算

​	返回一个布尔值
​	condition ? express1 : express2
​	condition 的式子里，运算结果会默认使用 Boolean() 方法进行隐式转换。

### （四） 逻辑运算

​	|| , && , !
​	如果两边都是boolean类型的数据，则返回运算后的boolean值；否则，则进行短路运算。

### （五） 使用Math对象进行数据运算

​	Math对象是ECMAScript内置的对象，可以对数据进行一些复杂的数学运算，常见的Math.round(),Math.floor(),Math.Ceil(),Math.abs(),Math.random()

### （六） 日期时间运算

​	Date对象是 ECMAScript 内置的对象，可以对时间进行各种赋值取值操作，常见的有 getTime(), getFullYear(), getMonth()（0-11）, getDate()（显示日期）,getDay()（显示周几，从周日开始算， 0-6）,  getHour(), getSecond(), getMinute()

## 二、 ECMAScript 的数据处理
​	数据的处理是语言的很重要的一部分，前端现在由于有Vue和React这样的MVVM类型的库（框架），因此前端现在很多的工作都是通过请求回后台数据，然后对数据进行处理，通过数据驱动框架视图的更新。对于现在的很多前端开发来说，数据处理占据了非常多的开发时间，因此掌握各种类型的数据处理方法是非常有必要的。

​	这里只讨论常见需要处理的的数据类型（String， Number，Object，Array）的处理。

### （一） String类型的处理
#### 1. 类型内的处理
##### (1) 检验

1. 是否包含（最粗粒度的检验）

   includes()  查询字符串是否包含子串，返回boolean ;

2. 开头和结尾（特定定位查询）

   startsWith() 查询字符串是否以子串开头； endswith() 查询字符串是否以子串结尾；都返回boolean ;

3. 查询位置（具体位置查询）

    indexOf() 查询字符串中第一次出现子串的位置，返回位置值。如果没出现，则返回 -1 ;

    lastIndexOf() 查询字符串中最后一次出现子串的位置，返回位置值。 如果没有出现，则返回 -1  ;

4. 模式匹配

    matcht(), 参数为正则表达式或RegExp对象，返回符合正则表达式的子串组成的数组。

##### (2) 拼接

1. 使用 + 号拼接， 将变量和数字等和已有的字符串拼接起来;
2. 使用模板字符串，使用${}填充变量和数字，更加直观，而且支持换行；
3. concat 方法，把传入的字符串拼接到调用该方法的字符串后面，然后返回（不会修改原字符串）；

##### (3) 获取子串

1. substring(start , end) , 传入两个参数，第一个参数必填，第二个参数可选，如果第一个参数不填，则返回从第一个参数到字符串最后的子串。

2. slice(start, end) , 和substring 功能一致，但是第二个参数可以接受负数，从数组末尾开始往前计数。

   注意，substring传入的两个参数，如果end 比start 小，那么会自动调换两个参数，然后返回子串，如果参数中传入负值，则全部处理成 0 ，然后进行字符串截取。

   slice 和 substring 都是 “包头不包尾”，即截取的子串是[start, end)。

##### (4) 查找替换

replace()，接受两个参数， 第一个是要替换的对象，可以是字符串或是RegExp对象； 第二个是替换文本或是替换文本的函数。

> 对于第二个参数是函数的情况，在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递3 个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为replace()方法的第二个参数可以实现更加精细的替换操作。

##### (5) 处理和合并

1. 转大小写： toUpperCase(), toLowerCase(), toLocalUpperCase(), toLocalLowerCase()
2. 合并空格： trim() 合并字符串前后的空格



#### 2. 转换成其他类型
##### (1) 转换成 Number 类型

1. 使用parseInt() 和parseFloat() , 可以把字符串转换为数值。parseInt可以接受两个参数，第二个参数是进制数，默认为10进制。解析时，从字符串的第一位开始，如果是数值，则继续往后解析到非数值位，返回解析的数值，否则返回NaN。
2. 对字符串进行减、乘、除运算，会隐式转换为数值，如果不能转换，则返回NaN。

##### (2) 转换成 Boolean 类型
​	在需要Boolean类型的表达式中，一般会将表达式的值隐式转换为Boolean类型的值。字符串一般都是返回true。注意字符串 "0" 转换成 true

##### (3) 转换成 Array 类型
​	使用split() 方法，将字符串根据指定的间隔符拆分成数组。

### （二） Number 类型的处理

#### 1. 进行各种运算

​	Number类型的数据，可以进行加减乘除以及使用Math对象进行运算，最常见的是遍历中 自增和自减 ；Math对象使用 Math.floor()向下取整，Math.ceil()向上取整，Math.abs() 取绝对值等。

#### 2. 取小数位

​	使用toFixed() 方法，传入保留几位小数，进行四舍五入保留指定位数的小数。（这个算法受 双精度浮点 算法的影响，可能不一定准确）。

#### 3. 指数表示

​	使用toExponential() 方法，接受一个参数，指定输出结果中小数位数，返回指数表示法表示的**数值字符串**形式。

​	使用 toPrecision() 方法，传入一个参数，指定输出结果中的小数位数，返回合适的格式表示数值（可能返回指数表示法，可能返回整数，可能返回小数）。

#### 4. 转换成其他类型

##### (1) 转换成Boolean 类型

​	在需要Boolean 类型的表达式中，除了 0 转化成false 以外，其他的都转化成 true （包括负数）。

##### (2) 转换成String 类型

​	使用字符串和 + 拼接符对数值进行操作的时候，转换成字符串。

### （三） Object 类型的处理

由于在 ECMAScript 中，对象的定义非常广，我在此只讨论狭义上的对象，而且不涉及原型链上的属性处理。

#### 1. 类型内的处理

##### (1) 检验

1. 检验对象中能否访问某个属性

   + 通过访问对象中的该属性，如果不是返回 undefined ,  那么说明该属性存在；

   + 遍历对象，然后看是否有等于该属性的 key；
2. 检验某个值是否是对象属性的值

   + 遍历对象查看是否有这样的属性值
3. 检验某个属性是否是对象本身的属性（而不是继承的）

   + 使用 hasOwnProperty() 方法，即可判断是对象本身的属性还是原型链上的属性。 
4. 获取对象所有key值
   + 使用Object.keys() 方法，返回对象所有**可直接枚举**的属性字符串组成的数组。
   + 使用Object.getOwnPropertyNames() 方法，返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。

##### (2) 属性值操作

取值，赋值，替换值，删除属性

1. 通过点语法或是[]， 获取对象对应的属性值。一般用点语法，在使用变量作为属性名的时候，用[] 。
2. 赋值操作就是将直接访问对象的属性值，然后使用 = 给其赋值。
3. 使用 delete 直接删除对象中的属性。

##### (3) 遍历

1. 使用for let key in obj 的语法，可以访问每一个可枚举的 key 。

##### (4) 复制

1. Object.assign() 和  JSON.parse(JSON.stringify())方法， 都可以根据传入的对象，生成单独的对象，在不改变原有的对象的基础上，对对象进行各种操作。

#### 2. 转换成其他类型

##### (1) 转换成基本数据类型

​	在对对象进行运算操作的时候，需要根据js的隐式转换原则将对象转换成指定的类型。在转换成基本类型时，一般都遵循这样的操作： 先访问对象的valueOf()方法，看是否有这样的方法，如果没有就访问对象的toString() 方法，否则返回字符串 [object Object] 

##### (2) 转换成 Array 类型

   	1. 可以通过遍历获取对象的key 或者 value 组成的数组；
   	2. 可以使用Object.keys 或是Object.getOwnPropertyNames() 方法获取对象的  key 组成的数组；
   	3. 使用Array.from(Object)方法，将**类数组和可遍历对象** 转为array；

### （三） Array 类型的处理

#### 1. 类型内的处理

##### (1) 检验

1. includes() 方法，检验数组是包含某个元素；
2. indexOf() 方法，返回数组中某个元素第一次出现的位置；
3. some() 方法，遍历数组，如果某一个元素满足条件，则返回true；
4. every() 方法，遍历数组，如果某一个元素不满足条件，则返回false；

##### (2) 元素操作

1. 从前插入：unshift() 方法，参数个数为一个或多个，从数组前面插入一个或多个元素，并返回数组新长度；
2. 从后推入：push() 方法， 参数为一个或多个，从数组后面添加一个或多个元素，并返回数组新长度；
3. 从前删除：shift() 方法，删除数组第一个元素，并返回该元素；
4. 从后删除：pop() 方法，删除数组最后一个元素，并返回该元素；
5. 替换/插入：splice(index，howmany，insert) 方法，删除index往后的howmany个，并在这个地方插入insert元素。如果howmany不传，则删除从index开始到数组结束的所有元素。
6. 查找元素：find() 方法，遍历元素，返回第一个符合回调函数条件的元素；

##### (3) 合并

1. 使用concat() 方法，可以传入一个或多个元素或数组，合并并返回（不改变原数组）；

##### (4) 翻转

1. 使用reverse 方法，翻转数组并返回数组（会改变原数组）；

##### (5) 遍历

1. forEach() 遍历数组，如果数组为空则不执行回调函数，不能使用 break 终止循环（使用 break 会报错）；
2. for of  和 for 循环 遍历数组， 能使用break 终止循环；
3. map() 方法遍历数组，返回数组每一个元素经过处理后组成的数组（数组长度不变）；
4. filter() 方法遍历数组，返回满足某些条件（return true）的元素组成的数组（数组长度小于或等于原数组）；
5. reduce 方法，传入一个回调函数，在回调函数中对每一个当前元素和累计值进行处理，最后返回处理值。

##### (6) 去重

1. 最快去重：[...new Set(arr)]；

2. 遍历去重；

   ```javascript
   function getNoRepeatArr(arr){
       for(let i = arr.length-1; i > 0; i--){
           if(isRepeat(arr, i)){
               arr.splice(i, 1)
           }
       };
       return arr;
   }
   function isRepeat(arr, index){
       for(let i = 0; i < index; i++){
           if(arr[index] == arr[i]){
               return true
           }
       }
       return false;
   }
   
   console.log(getClearArr([2,"a","a",2,2,1,1,2])) //[2, "a", 1]
   ```

##### (7) 排序

1. sort() 方法，传入一个方法，方法有两个参数，是当前比较的两个值，根据return 的值是否大于零决定另个元素的位置；

##### (8) 获取子数组

1. slice() 方法，传入开始和结束的index ，返回子数组；

2. filter() 方法， 返回符合条件（回调函数里面返回true）的子数组；

#### 2. 转换成其他类型

##### (1) 转换成 String 类型

1. 使用join() 方法，用指定的间隔符将数组的元素串起来，返回字符串；

2. 隐式转换，在和字符串做拼接或是比较运算的时候，先调用数组的valueOf方法（如果没重写的话就是返回数组本身），再调用toString方法（如果没重写就跟join方法一样，默认用逗号连接）；

##### (2) 转换成 Number 类型

​	隐式转换成 Number 类型，跟转成 String 类型一样的步骤。




